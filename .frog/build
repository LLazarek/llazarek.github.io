((3) 0 () 4 ((p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-07-09-modal-editing-emacs.md" . unix) (p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-07-02-org-mode.md" . unix) (p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-07-09-better-agenda.md" . unix) (p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-05-22-ptext.scrbl" . unix)) () (h ! (equal) ((p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-07-09-better-agenda.md" . unix) f post (u . "Improving the Agenda") (? . 2) 1532058725 (p+ #"/home/lukas/github_sync/projects/website/2018/07/improving-the-agenda.html" . unix) (u . "/2018/07/improving-the-agenda.html") (u . "2018-07-09T03:27:27") (? . 0) #f (c (u . "emacs") c (u . "org")) (u . "\n<p>Org mode&rsquo;s agenda is a fantastic interface for viewing and managing tasks. However, its default display settings get cluttered with large numbers of tasks, making it difficult to see what really needs to be done. Here are some of the ways I make the agenda crystal clear.</p>") #t (u . "\n<p>Org mode&rsquo;s agenda is a fantastic interface for viewing and managing tasks. However, its default display settings get cluttered with large numbers of tasks, making it difficult to see what really needs to be done. Here are some of the ways I make the agenda crystal clear.</p>\n<!-- more-->\n\n<br />\n\n<br />\n\n<h1 id=\"context\">Context</h1>\n\n<p>I have found org mode&rsquo;s agenda an invaluable tool for keeping myself organized over the years. However, I can easily see how many newcomers to org fail to see its potential; the default display settings for the agenda leave much to be desired. Indeed, when I first started using the agenda to plan and manage my work, I often found myself staring at the agenda, overwhelmed by the sheer number of tasks and struggling to figure out what really needed to be done <span class=\"underline\">now</span>.</p>\n\n<p>A few appearance tweaks can make a world of difference, however. The primary tools for doing this are simply color and text emphasis (bold, italics, underline). The default settings don&rsquo;t really leverage colors and text emphasis to group and highlight tasks. The second tool available is controlling the sorting of tasks with priorities. Finally, the agenda provides rich filtering tools to make dealing with lots of disparate tasks a little easier.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"grouping-and-emphasizing-tasks-with-color\">Grouping and emphasizing tasks with color</h1>\n\n<p>The most obvious way to help make more visual sense of the agenda is to color-code tasks. While this functionality is not built-in, it&rsquo;s quite easy to add. I think the most useful way to do this (thought not the easiest, see below) is by associating colors with tags, and colorizing tasks in the agenda according to their tags. The following function does just that; it can be invoked in <code>org-finalize-agenda-hook</code>. (Note that I can&rsquo;t claim full credit for this function, it is largely based on a stackoverflow answer I have since forgotten.)</p>\n\n<pre><code>(defun ll/org/agenda/color-headers-with (tag col)\n  \"Color agenda lines matching TAG with color COL.\"\n  (interactive)\n  (goto-char (point-min))\n  (while (re-search-forward tag nil t)\n    (unless (find-in-line \"\\\\[#[A-Z]\\\\]\")\n      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)\n                          (point-at-bol)))\n            (tags-beginning (or (find-in-line \" :\" t)\n                                (point-at-eol))))\n        (add-text-properties todo-end\n                             tags-beginning\n                             `(face (:foreground ,col)))))))\n\n;; Helper definitions\n(setq ll/org/agenda-todo-words\n      '(\"TODO\" \"GOAL\" \"NEXT\" \"STARTED\" \"WAITING\" \"REVIEW\" \"SUBMIT\"\n        \"DONE\" \"DEFERRED\" \"CANCELLED\"))\n(defun find-in-line (needle &amp;optional beginning count)\n  \"Find the position of the start of NEEDLE in the current line.\n  If BEGINNING is non-nil, find the beginning of NEEDLE in the current\n  line. If COUNT is non-nil, find the COUNT'th occurrence from the left.\"\n  (save-excursion\n    (beginning-of-line)\n    (let ((found (re-search-forward needle (point-at-eol) t count)))\n      (if beginning\n          (match-beginning 0)\n        found))))\n(defun ll/org/agenda/find-todo-word-end ()\n  (reduce (lambda (a b) (or a b))\n          (mapcar #'find-in-line ll/org/agenda-todo-words)))</code></pre>\n\n<p>Example usage:</p>\n\n<pre><code>(defun ll/org/colorize-headings ()\n  ;; Color all headings with :pers: tan\n  (ll/org/agenda/color-headers-with \":pers:\" \"tan\")\n  ;; and :work: blue\n  (ll/org/agenda/color-headers-with \":work:\" \"blue\"))\n(add-hook 'org-agenda-finalize-hook #'ll/org/colorize-headings)</code></pre>\n\n<p>Note that this function iterates over the agenda entries, modifying their face each time it is called. So if an entry has a tag that is matched by more than one call to this function (e.g. it&rsquo;s tagged with <code>:pers:work:</code>), then <span class=\"underline\">the task will have the color of the last call</span>.</p>\n\n<p>Another way to do color coding (which takes precedence over the above method) is using priorities (about which I&rsquo;ll say more later). Org has a built-in mechanism to colorize and emphasize tasks marked with <a href=\"https://orgmode.org/manual/Priorities.html#Priorities\">a priority</a> (<code>[#A]</code>, <code>[#B]</code>, etc). Thus, it&rsquo;s straightforward to do. In general though, I prefer the tag-based coloring for grouping/categorizing tasks. This is the configuration I use, highlighting tasks with priority A in bolded magenta, B in light green, and C in orange.</p>\n\n<pre><code>(customize-set-variable 'org-agenda-fontify-priorities t)\n(customize-set-variable 'org-priority-faces\n                        (quote ((?A :foreground \"magenta\" :weight bold)\n                                (?B :foreground \"green3\")\n                                (?C :foreground \"orange\"))))</code></pre>\n\n<br />\n\n<br />\n\n<h1 id=\"sorting\">Sorting</h1>\n\n<p>Another way to help identify important tasks more easily is using sorting. As you might have guessed, priorities are not only useful for highlighting tasks; they also affect the sorting of tasks in the agenda. Higher priority tasks show up before lower priority ones within the same category (overdue, scheduled, deadline) in the agenda. By default, tasks have a priority of B; I find this unintuitive, so I set the default priority to C. This way tasks with priority A show first, then B, then C, then the rest.</p>\n\n<pre><code>;; Set default priority to C\n(customize-set-variable 'org-default-priority ?C)</code></pre>\n\n<p>You might ask &ldquo;why not make the default priority be lower than C, so that tasks with any priority at all show up first?&rdquo; It turns out that the default priority has to be at least the lowest priority (<code>org-lowest-priority</code>), which by default is C. Of course, it is possible to have as low a priority as you like (within reason), such as D, E, &#8230;, Z. I don&rsquo;t find that to be useful, however. Two high-priority priorities are enough.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"filtering\">Filtering</h1>\n\n<p>The agenda also provides filtering functions to restrict the displayed tasks. They are pretty self-explanatory; in the agenda, hit \"/\" to filter by tag and \"=\" to filter by regular expression. Press \"/\" again to clear or narrow further, or in the case of regexp filtering press \"|\" to clear the filter.</p>\n\n<p>The only noteworthy point about filtering is that the tag filter cannot express disjunction. This has caused me some grief, as I have wanted to filter with something like &ldquo;work OR school&rdquo;. The solution, though, is to just use the regexp filter with a pattern like \":(work|school)\".</p>\n\n<br />\n\n<br />\n\n<h1 id=\"showing-more-stuff\">Showing more stuff</h1>\n\n<p>Having cleaned up the agenda and made it easier to read, it might become appealing to start showing more relevant details. For example, seeing the notes in the body of a task is sometimes useful. Alternatively, it might be useful to see the value of some <a href=\"https://orgmode.org/manual/Properties-and-columns.html#Properties-and-columns\">properties of the task</a>. Of course, the agenda can do it.</p>\n\n<p>Showing context lines from the body of the task is as simple as pressing a key in the agenda; &ldquo;E&rdquo; invokes <code>org-agenda-entry-text-mode</code> (see <a href=\"https://orgmode.org/manual/Agenda-commands.html#Agenda-commands\">the manual</a>), showing some lines from the body of the task. To enable this behavior by default, configure <code>org-agenda-start-with-entry-text-mode</code>. The number of lines can also be configured with <code>org-agenda-entry-text-maxlines</code>. For example:</p>\n\n<pre><code>;; Show context lines by default in the agenda\n(customize-set-variable 'org-agenda-start-with-entry-text-mode t)\n;; Show up to 4 lines of context\n(customize-set-variable 'org-agenda-entry-text-maxlines 4)</code></pre>\n\n<p>However, I find that the context provided by org creates too much clutter to be useful. This is especially true when I have stuff written in the body of a task that I <em>don&rsquo;t</em> want to see in the agenda (often): <code>entry-text-mode</code> provides no way to configure <em>which</em> entries to show context for. Thus, I prefer the alternative way to show more information, which is to show the values of specific properties when they are present in the task.</p>\n\n<p>Showing property values in the agenda is provided by the excellent <a href=\"https://github.com/Malabarba/org-agenda-property\">org-agenda-property package</a>, available on MELPA. Here&rsquo;s the configuration that I use to show the value in three properties that I use to record why a task is blocked, deferred, or canceled, and to write short notes on the task.</p>\n\n<pre><code>(use-package org-agenda-property\n  :config\n  (customize-set-variable 'org-agenda-property-list\n                          '(\"WAITING?\" \"DEFERRED?\" \"CANCELLED?\" \"NOTE\"))\n  (customize-set-variable 'org-agenda-property-position 'same-line))</code></pre>")) ((p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-07-02-org-mode.md" . unix) f post (u . "Organization with Org Mode") (? . 1) 1532058680 (p+ #"/home/lukas/github_sync/projects/website/2018/07/organization-with-org-mode.html" . unix) (u . "/2018/07/organization-with-org-mode.html") (u . "2018-07-02T11:37:07") (? . 3) (? . 0) (c (u . "emacs") c (u . "org")) (u . "\n<p>I organize myself and my work using emacs&rsquo; org mode. It has served me extremely well over the past few years and has helped me better organize both my working and personal life. In this post, I describe how I use org mode for everything from long-term projects to appointments and ideas.</p>") #t (u . "\n<p>I organize myself and my work using emacs&rsquo; org mode. It has served me extremely well over the past few years and has helped me better organize both my working and personal life. In this post, I describe how I use org mode for everything from long-term projects to appointments and ideas.</p>\n<!-- more-->\n\n<br />\n\n<br />\n\n<h1 id=\"context\">Context</h1>\n\n<p>I used to use a paper calendar to keep track of tasks, deadlines, and events. I pretty quickly found it generally ineffective for long term planning because I would need to actively look ahead through the pages of the calendar to find things that needed to be done. Of course, I rarely did that and was often surprised by forgotten tasks.</p>\n\n<p>I then transitioned to Google calendar, using events for tasks and deadlines. I liked it because with the month view I could clearly see things that needed to get done, and I could color code things into categories.</p>\n\n<p>This, too, eventually started to become unsatisfying. For one, the calendar frequently became cluttered and difficult to parse, especially when too many events landed on a single day, causing them to be hidden. Wanting to avoid this clutter, I was unwilling to track personal tasks; which, upon reflection, was absurd: my organization system deterred me from being organized. Add onto this a number of other small annoyances about the unsupported ways I wanted to use the calendar, and I wasn&rsquo;t terribly happy with it. Finally, I decided that it was perhaps not the best idea for Google to know and be in control of every significant detail of my life.</p>\n\n<p>So after some searching, I decided to try org mode as a flexible offline solution to organize myself. It had the extra benefit of keeping everything completely in plain text, eliminating any concern about lock-in and making it easy to compose with standard Unix tools.</p>\n\n<p>It has been a few years since then, and I have never really looked back; org is flexible and expressive enough to do everything I wanted and more. What I present below has undergone many iterations since I began using org. It incorporates influences from Bernt Hansen&rsquo;s excellent <a href=\"http://doc.norang.ca/org-mode.html\">&ldquo;Organize Your Life in Plaintext&rdquo; guide</a>, GTD, and other myriad sources. I consider the system something of a continually evolving experiment, and I often try new approaches or ideas in a constant drive to improve it. Nonetheless, it already far surpasses any other system I have used or heard of.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"basic-organization\">Basic Organization</h1>\n\n<h2 id=\"file-structure\">File structure</h2>\n\n<p>I keep all of my task and appointment information in a single file. Within that file, I use headings to group everything into major categories; for example, my top-level headings include (<code>school, grad school, work, personal, appointments</code>). Within each category I use subcategories of arbitrary depth as I see fit. For example, under <code>school</code> I used a second level heading for each course I was taking, and under <code>work</code> headings for each project I worked on. When it&rsquo;s not clear what the subcategories need to be upon making a new category, I won&rsquo;t have any until it becomes clear what they should be. I don&rsquo;t worry about this file being heavily nested or difficult to navigate, because I almost never look at it or navigate through it directly (more on that in Seeing what needs to be done: the agenda).</p>\n\n<h2 id=\"tasks\">Tasks</h2>\n\n<p>The headings create a tree structure, and the leaves of the tree are tasks. I denote any heading marked with a <code>TODO</code> keyword as a task; conceptually, a task represents something discrete that needs to be done. Examples include a paper or report, a chore, an email to respond to, an appointment to complete, a flight to catch&#8230; Anything I can mark as having been completed. Tasks have a brief, informative heading on what needs to be done - this is important because the heading is what I see when looking through my tasks. The task may also have some notes, extra details, or (typically) links in it&rsquo;s body.</p>\n\n<p>I use a number of different <a href=\"https://orgmode.org/worg/org-glossary.html#todo-keywords\">TODO keywords</a> in addition to the basic <code>TODO</code> and <code>DONE</code>. The full set of keywords I use is, in this order: <code>(TODO NEXT STARTED WAITING REVIEW SUBMIT | DONE DEFERRED CANCELLED)</code>. I use <code>TODO</code> generally to mark a task. <code>NEXT</code> indicates a task that I intend to work on next or today (it serves as a quick way to single out tasks). <code>STARTED</code> means that the task has been started and is in progress. <code>WAITING</code> marks tasks that are blocked and un-actionable pending something beyond my control - like getting an email response, or receiving information from someone else. <code>REVIEW</code> means that the task requires review before completing (or some similar other final actions), but is pretty much complete. <code>SUBMIT</code> is similar to <code>REVIEW</code>, but specifically marks tasks that are completely done but need to be submitted somewhere. <code>DONE</code> means that a task is completely done. <code>DEFERRED</code> marks tasks that I have decided not to do for the time being, though I may at a later time revive them. <code>CANCELLED</code> marks tasks that I have canceled outright. Note that the bar separating <code>DONE</code> <code>DEFERRED</code> and <code>CANCELLED</code> marks those states as all representing \"done\"ness, so that tasks with those keywords won&rsquo;t be considered when I am viewing tasks to do.</p>\n\n<p>Finally, a task always has a date attached: either a <code>SCHEDULED</code> or a <code>DEADLINE</code> date (there is one exception to this: chaining tasks). Having one of these two dates is critical, because they are central to my task management. The primary factor by which I sort and view my tasks is date, so a task without a date won&rsquo;t be seen, and since I very rarely manually traverse my main file, it will certainly be forgotten.</p>\n\n<p>The two types of dates have very different meanings, however. A <code>DEADLINE</code> date represents, intuitively, a hard deadline for a task. Failure to complete a task by its deadline is usually a big problem, so these dates have a heavy weight in my prioritization scheme. I usually give all important tasks a deadline to ensure I actually do them and have fair warning about them. A <code>SCHEDULED</code> date, on the other hand, has a less rigid meaning. Scheduling a task for a given day generally just means that I want to be reminded of the task on that day. Thus, I use scheduling for less important tasks that I want reminders for, but that needn&rsquo;t necessarily be done exactly then. For example, exercising, small chores, and soft-deadline tasks.</p>\n\n<p>Note that this approach to using scheduled dates is <strong>not</strong> what is described in the org manual or most org guides. I tried using scheduled dates in the manner they were intended, which is to mark the day I should <strong>start</strong> working on a task, but I found that this never really worked usefully because it&rsquo;s really hard to predict when I can start working on things. In particular, individual tasks almost always take more or less time than I expect, and there are often circumstances that make working on specific tasks more or less desirable at a given time (including my mood) but which are impossible to predict ahead of time. In short, I prefer to just be able to see the full set of what needs to get done and pick what to do when I&rsquo;m actually going to do it.</p>\n\n<h2 id=\"chaining-tasks\">Chaining tasks</h2>\n\n<p>The only case when I intentionally leave a task without a date is if I have a series of tasks that naturally form a chain. That is, I have a series of tasks A, B, and C that must be done in order. In that case, I number the tasks in the title to indicate that they are part of a chain, and then I only put a date on the foremost non-done task. For example, this is how a chain of three tasks would progress over time:</p>\n\n<pre><code>* Some project               --&gt;     * Some project               --&gt;     * Some project\n** TODO (1) Fix bug                  ** DONE (1) Fix bug                  ** DONE (1) Fix bug\nSCHEDULED: &lt;2018-07-09 Mon&gt;          ** TODO (2) Add new feature          ** DONE (2) Add new feature\n** TODO (2) Add new feature          SCHEDULED: &lt;2018-07-09 Mon&gt;          ** TODO (3) Update docs\n** TODO (3) Update docs              ** TODO (3) Update docs              SCHEDULED: &lt;2018-07-09 Mon&gt;</code></pre>\n\n<h2 id=\"capturing-new-tasks\">Capturing new tasks</h2>\n\n<p>I almost always add new tasks using <a href=\"https://orgmode.org/manual/Capture.html#Capture\">org-capture</a>. Rather than searching through my entire file for the place to put a new task, with capture I can quickly create a new task and then <a href=\"https://orgmode.org/manual/Refile-and-copy.html#Refile-and-copy\">refile it</a> into a good spot (using fuzzy search!) from anywhere in emacs.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Extended notes (for or about pretty much everything) <span class=\"underline\">do not go into my main file</span>. It is a place for tasks and tasks only. I keep all my notes in separate org files, and usually link to them from the relevant tasks. If they don&rsquo;t necessarily relate to any tasks - or any active tasks anyway - then I have them accessible through <a href=\"https://jblevins.org/projects/deft/\">deft</a> which is a fantastic package for searching plain text notes. Since org is just plain text, it all works perfectly!</p>\n\n<h2 id=\"cleaning-things-up-archiving\">Cleaning things up: archiving</h2>\n\n<p>Since I keep track of just about everything I do using tasks, my main org file gets very cluttered with completed tasks over time. This isn&rsquo;t necessarily problem, since I rarely look at it anyway, except that it slows down org and the agenda a bit. So around once a year I go through the file and clean out completed tasks. I do this using <a href=\"https://orgmode.org/manual/Archiving.html#Archiving\">org&rsquo;s built-in archiving mechanism</a>.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"non-structural-organization\">Non structural organization</h1>\n\n<p>There are two primary ways that I further organize information and tasks beyond the tree structure of headings.</p>\n\n<h2 id=\"tags\">Tags</h2>\n\n<p>I use tags to categorize and prioritize tasks. Specifically, tags are useful for narrowing my agenda view and for searching and grouping tasks in clock reports. The most obvious way I use tags is to group things, such as tagging all the tasks related to a course with a tag for the course. The second way I use them is to mark tasks with priority labels like high, low, etc. Actually, I experimented with multiple levels of priority for a while and found that just two levels works best for me. That is, I mark prioritized tasks with the tag <code>:goal:</code>, and all other tasks are not prioritized. That doesn&rsquo;t mean I can&rsquo;t or won&rsquo;t do other tasks, just that they won&rsquo;t be emphasized in the agenda.</p>\n\n<p>I use another dimension to prioritize tasks, inspired by something like the <a href=\"https://www.developgoodhabits.com/eisenhower-matrix/\">Eisenhower prioritization matrix</a>, where I tag tasks as either <code>:must:</code> or <code>:want:</code>, depending on if I must or simply want to do them. I find that this further helps me to quickly and easily decide which tasks to work on and in what order.</p>\n\n<h2 id=\"links\">Links</h2>\n\n<p>I think that <span class=\"underline\">links are one of org modes greatest strengths.</span> Org has a <a href=\"https://orgmode.org/manual/Hyperlinks.html\">particularly rich link system</a> that allows creating \"clickable” links to quickly access related information. Links can refer to files and websites, of course, as well as more interesting things like specific headings in the same or other files, or chunks of text in a file, and can even evaluate arbitrary expressions, making them effectively general purpose buttons. Their flexibility makes them extremely useful for easily accessing disparate information. Any tasks I create relating to some other information has links to the relevant files, emails, websites, programs (remember that links can execute code?). This minimizes the inertia time involved in getting oriented to a new task; no need to think about where to find the right files or what to look at, because it&rsquo;s all in the links!</p>\n\n<br />\n\n<br />\n\n<h1 id=\"seeing-what-needs-to-be-done-the-agenda\">Seeing what needs to be done: the agenda</h1>\n\n<p><a href=\"https://orgmode.org/manual/Agenda-views.html#Agenda-views\">The agenda</a> is the tool for viewing tasks. Instead of looking at my org file (which I in some ways consider to be the &ldquo;source&rdquo; for generating the agenda), I exclusively look at the agenda to see what needs to be done. At it&rsquo;s most basic, the agenda shows the tasks with scheduled and deadline dates for each day in the current week, starting with today. It also shows &ldquo;warnings&rdquo; for upcoming deadlines and the number of days until they become due. Thus, from looking at my agenda for today it is clear from the upcoming deadlines which important tasks need to get done and how soon, and from the scheduled items I am reminded of less important tasks and information.</p>\n\n<p>The agenda also provides a better interface for manipulating tasks. Tasks&rsquo; <code>TODO</code> state can be changed, their scheduled and deadline dates shifted, tags updated, and priority updated. You can also quickly clock in to or out of tasks right in the agenda.</p>\n\n<p>Since the main job of the agenda is to help me quickly see the tasks that need to be done, <a href=\"https://orgmode.org/manual/Filtering_002flimiting-agenda-items.html#Filtering_002flimiting-agenda-items\">its filtering capabilities</a> can be useful for focusing on specific groups of tasks. The most common filter I use is tag filtering or, for something more complex, regexp filtering (usually again on tags, however).</p>\n\n<h2 id=\"emphasizing-prioritized-tasks\">Emphasizing prioritized tasks</h2>\n\n<p>Filtering often isn&rsquo;t the best solution, however; <em>emphasis</em> often works just as well or better, especially for general task selection. Filtering is not ideal because I usually want to be aware of the other tasks, even if I&rsquo;m not working on them right now. To de-emphasize unprioritized tasks instead of hiding them, I adapted a solution for color coding tagged agenda tasks to render all tasks missing the :goal: tag in a light gray font, leaving :goal: tagged tasks in full black. I have found this to be a perfect middle ground: my prioritized tasks clearly stand out from the rest, while still leaving the others visible and accessible.</p>\n\n<h2 id=\"starting-tasks-quickly\">Starting tasks quickly</h2>\n\n<p>The last important element of the agenda for my workflow is that using <code>org-open-at-point</code> (<a href=\"https://orgmode.org/manual/Handling-links.html\">manual</a>) the links in the body of a task can be opened directly from the agenda, making it that much easier to jump into a task. Thus, my usual workflow for starting a new task is to (from the agenda) clock into the task and then open whatever links it contains - because of this, <span class=\"underline\">nearly all of my tasks contain links to something</span>.</p>\n\n<h2 id=\"aside-improving-the-agenda-view\">Aside: improving the agenda view</h2>\n\n<p>For more about the agenda and optimizing its appearance to make surveying tasks quick and easy, check out my other post on tweaking the agenda&rsquo;s display settings: <strong>todo link</strong>.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"evaluation-and-reflection\">Evaluation and reflection</h1>\n\n<h2 id=\"clocking-work\">Clocking work</h2>\n\n<p>As I have mentioned, I use <a href=\"https://orgmode.org/manual/Clocking-work-time.html#Clocking-work-time\">org&rsquo;s clocking facilities</a> to track how I spend my time working. I have found that, of nothing else, knowing that the clock is running helps to keep me focused on the task at hand. Additionally, knowing how long I actually spend working on things has helped put my work and habits into perspective.</p>\n\n<p>In conjunction with clocking, I have for some time used a <a href=\"https://en.wikipedia.org/wiki/Pomodoro_Technique\">pomodoro approach</a> to structuring my work. I find that it helps me stay focused and gives an even better sense of time wrt work when I can think of working time in terms of pomodoros. I usually use 50-minute pomodoros, but depending on the task and my mood I have used 30m and 90m as well. To do this with org, I have hooked a pomodoro timer into my clock-in function so that the timer starts automatically every time I clock into a task.</p>\n\n<h2 id=\"seeing-the-work-i-have-done\">Seeing the work I have done</h2>\n\n<p>The agenda provides an option to display the tasks clocked and completed today (called <a href=\"https://orgmode.org/manual/Agenda-commands.html\">logbook mode</a>) which I greatly appreciate. I find it motivating and pleasing to see the fruits of my labor recorded in the agenda.</p>\n\n<p>Finally, for more comprehensive, long-term review of the work I have done over some period of time I use <a href=\"https://orgmode.org/manual/The-clock-table.html#The-clock-table\">org&rsquo;s clock reports</a>. With a clock report org mode can generate a table summarizing all of the time clocked over any period of time. I use this to do a regular review of my work every few days. Again, I find it helps me to see what I have been working on and where my time has been spent, which ultimately helps me plan work more effectively in the future.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"the-code\">The code</h1>\n\n<p>I have heavily customized my org configuration to support the workflow I have described. Below is all of the code that enables the above workflow, as well as a few other minor things I have not described but have also found useful.</p>\n\n<h2 id=\"todo-keywords\">Todo keywords</h2>\n\n<p>This sets the todo keyword sequence and their colors.</p>\n\n<pre><code>(setq org-todo-keywords\n      (quote ((sequence \"TODO(t)\" \"NEXT(n)\" \"STARTED(s)\" \"WAITING(w)\"\n                        \"REVIEW(r)\" \"SUBMIT(m)\"\n                        \"|\" \"DONE(d)\" \"DEFERRED(f)\" \"CANCELLED(c)\"))))\n(setq org-todo-keyword-faces\n      (quote ((\"TODO\"      :foreground \"red\"          :weight bold)\n              (\"NEXT\"      :foreground \"blue\"         :weight bold)\n              (\"STARTED\"   :foreground \"cyan\"         :weight bold)\n              (\"WAITING\"   :foreground \"gold\"         :weight bold)\n              (\"REVIEW\"    :foreground \"magenta\"      :weight bold)\n              (\"SUBMIT\"    :foreground \"sea green\"    :weight bold)\n              (\"DONE\"      :foreground \"forest green\" :weight bold)\n              (\"DEFERRED\"  :foreground \"dark red\"     :weight bold)\n              (\"CANCELLED\" :foreground \"dark red\"     :weight bold))))</code></pre>\n\n<h2 id=\"agenda\">Agenda</h2>\n\n<h3 id=\"basic-formatting\">Basic formatting</h3>\n\n<p>This modifies agenda formatting; refer to comments for specific changes.</p>\n\n<pre><code>;; Don't display holidays that I don't follow\n(customize-set-variable 'holiday-bahai-holidays nil)\n(customize-set-variable 'holiday-hebrew-holidays\n                        (quote ((holiday-hebrew-hanukkah)\n                                (if calendar-hebrew-all-holidays-flag\n                                    (append (holiday-hebrew-tisha-b-av)\n                                            (holiday-hebrew-misc))))))\n(customize-set-variable 'holiday-islamic-holidays nil)\n\n;; Modify the way that entries with time specifications are displayed\n(customize-set-variable 'org-agenda-use-time-grid t)\n(customize-set-variable 'org-agenda-time-grid\n                        (quote ((daily today require-timed)\n                                #(\"-----------------------------------\"\n                                  0 35 (org-heading t))\n                                (0 2400))))\n(customize-set-variable 'org-agenda-current-time-string\n                        #(\"now - - - - - - - - - - - - - - - -\"\n                          0 35 (org-heading t)))\n;; Modify the way that deadlines are displayed\n(customize-set-variable 'org-agenda-deadline-leaders\n                        '(\"Deadline:  \" \"----- In %3d d.: -----\"))\n;; And scheduled items\n(customize-set-variable 'org-agenda-scheduled-leaders\n                        '(\"&gt;&gt; Scheduled: &lt;&lt;\" \"** Sched.%2dx: **\"))\n\n;; Don't warn me of an upcoming deadline if I schedule the entry\n(customize-set-variable 'org-agenda-skip-deadline-prewarning-if-scheduled t)\n;; Don't show scheduled entries that have been completed\n(customize-set-variable 'org-agenda-skip-scheduled-if-done t)\n\n;; Don't start with context lines from entry body\n(customize-set-variable 'org-agenda-start-with-entry-text-mode nil)\n;; If context lines are enabled, show up to 4 lines\n(customize-set-variable 'org-agenda-entry-text-maxlines 4)\n\n;; Pull data for agenda from these files\n(customize-set-variable 'org-agenda-files\n                        '(\"~/notes/main.org\"))\n\n;; Don't slow down startup when generating the agenda\n(customize-set-variable 'org-agenda-inhibit-startup nil)\n\n;; Show 14 days per page in the agenda\n(customize-set-variable 'org-agenda-span 14)\n;; Show upcoming deadlines for the 4 weeks\n(customize-set-variable 'org-deadline-warning-days 28)\n;; Start the agenda on today\n(customize-set-variable 'org-agenda-start-on-weekday nil)\n\n;; Set default priority to C\n(customize-set-variable 'org-default-priority 67)\n;; Color-code priorities\n(customize-set-variable 'org-agenda-fontify-priorities t)\n(customize-set-variable 'org-priority-faces\n                        (quote ((65 :foreground \"magenta\" :weight bold)\n                                (66 :foreground \"green3\")\n                                (67 :foreground \"orange\"))))\n\n;; Increase line spacing and highlight current line\n(defun ll/org/agenda/appearance-hook ()\n  (setq line-spacing 4)\n  (hl-line-mode 1))\n(add-hook 'org-finalize-agenda-hook #'ll/org/agenda/appearance-hook)\n\n;; Log when tasks completed\n(customize-set-variable 'org-log-done t)\n;; Show clocked items for the day in the agenda\n(customize-set-variable 'org-agenda-start-with-log-mode t)</code></pre>\n\n<h3 id=\"emphasis-and-prioritization\">Emphasis and prioritization</h3>\n\n<p>This implements tag-based emphasis in the agenda.</p>\n\n<pre><code>;; Color code tags\n;; `focus-mode' is what I call the toggle switch for de-emphasizing tasks\n(setq ll/org/agenda/focus-mode t)\n(defun ll/org/agenda/focus-mode-hook ()\n  (save-excursion\n    (progn\n      (when ll/org/agenda/focus-mode\n        ;; De-emphasize all headings by making them lighter\n        (ll/org/agenda/color-headers-with \":\" \"dark gray\"))\n      ;; Re-emphasize priority headings by making them black\n      (ll/org/agenda/color-headers-with \":goal:\" \"black\"))))\n(add-hook 'org-finalize-agenda-hook #'ll/org/agenda/focus-mode-hook)\n\n(defun ll/org/agenda/toggle-focus-mode ()\n  \"Toggle greying out of non-goal lines in the agenda.\"\n  (interactive)\n  (setq ll/org/agenda/focus-mode (not ll/org/agenda/focus-mode)))\n\n(defun find-in-line (needle &amp;optional beginning count)\n  \"Find the position of the start of NEEDLE in the current line.\n  If BEGINNING is non-nil, find the beginning of NEEDLE in the current\n  line. If COUNT is non-nil, find the COUNT'th occurrence from the left.\"\n  (save-excursion\n    (beginning-of-line)\n    (let ((found (re-search-forward needle (point-at-eol) t count)))\n      (if beginning\n          (match-beginning 0)\n        found))))\n\n(setq ll/org/agenda-todo-words\n      '(\"TODO\" \"GOAL\" \"NEXT\" \"STARTED\" \"WAITING\" \"REVIEW\" \"SUBMIT\"\n        \"DONE\" \"DEFERRED\" \"CANCELLED\"))\n\n(defun ll/org/agenda/find-todo-word-end ()\n  (reduce (lambda (a b) (or a b))\n          (mapcar #'find-in-line ll/org/agenda-todo-words)))\n\n;; This comes from a stackoverflow question I forgot to record..\n(defun ll/org/agenda/color-headers-with (tag col)\n  \"Color agenda lines matching TAG with color COL.\"\n  (interactive)\n  (goto-char (point-min))\n  (while (re-search-forward tag nil t)\n    (unless (find-in-line \"\\\\[#[A-Z]\\\\]\")\n      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)\n                          (point-at-bol)))\n            (tags-beginning (or (find-in-line \" :\" t)\n                                (point-at-eol))))\n        (add-text-properties todo-end\n                             tags-beginning\n                             `(face (:foreground ,col)))))))</code></pre>\n\n<h2 id=\"refiling\">Refiling</h2>\n\n<p>This configures refiling with <code>org-refile</code>.</p>\n\n<pre><code>;; Refile to current file, main file, or \"someday\" file\n;; (in that order of precedence)\n(setq org-refile-targets '((nil :maxlevel . 2) ; current file\n                           (org-agenda-files :maxlevel . 5)\n                           (\"oneday-someday.org\" :maxlevel . 2)))\n;; Narrow refile targets by heading &gt; subheading\n(setq org-outline-path-complete-in-steps nil)\n;; Show full heading paths for refiling\n(setq org-refile-use-outline-path t)</code></pre>\n\n<h2 id=\"capture\">Capture</h2>\n\n<p>This configured capturing tasks with <code>org-capture</code>.</p>\n\n<pre><code>(global-set-key (kbd \"C-c j\") 'org-capture)\n(customize-set-variable 'org-capture-templates (quote (\n    (\"t\" \"Insert a new TODO\" entry\n     (file+headline \"~/github_sync/Notes/Main.org\" \"Refile\")\n     \"** TODO %?\n\")\n    (\"n\" \"Insert a new NEXT\" entry\n     (file+headline \"~/github_sync/Notes/Main.org\" \"Refile\")\n     \"** NEXT %?\n\"))))</code></pre>\n\n<h2 id=\"clocking\">Clocking</h2>\n\n<p>This configured clocking and pomodoro timers.</p>\n\n<pre><code>(customize-set-variable 'org-clock-into-drawer \"LOGBOOK\")\n(customize-set-variable 'org-time-clocksum-format (quote (:hours \"%d\"\n                                                          :require-hours t\n                                                          :minutes \":%02d\"\n                                                          :require-minutes t)))\n(setq org-time-clocksum-use-fractional t)\n\n;; Clocktable spacing appearance\n(defun ll/org/clocktable-indent-string (level)\n  (if (= level 1)\n      \"\"\n    (let ((str \"└\"))\n      (while (&gt; level 2)\n        (setq level (1- level)\n              str (concat str \"──\")))\n      (concat str \"─&gt; \"))))\n\n(advice-add 'org-clocktable-indent-string\n            :override #'ll/org/clocktable-indent-string)\n\n;; Pomodoro timer upon clocking in\n(customize-set-variable 'org-clock-sound\n                        \"/home/lukas/github_sync/notification.wav\")\n;; Default timer length\n(customize-set-variable 'org-timer-default-timer 50) ; minutes\n(add-hook 'org-clock-in-hook (lambda ()\n                               ;; '(4) means just use default duration\n                               (org-timer-set-timer '(4))))</code></pre>\n\n<h2 id=\"archiving\">Archiving</h2>\n\n<p>This configures where archive files are kept/named.</p>\n\n<pre><code>(customize-set-variable 'org-archive-location \"archive_%s::\")</code></pre>\n\n<h2 id=\"tags\">Tags</h2>\n\n<p>This helper function makes it easier to set the tags of the current heading.</p>\n\n<pre><code>(defun ll/org/set-tags ()\n  \"Set the tags of the current heading, like\n`org-agenda-set-tags' for outside the agenda.\"\n  (interactive)\n  (save-excursion\n    (end-of-line) ;; Prevent getting prev heading if at start of curr heading\n    (let* ((org-context (org-element-type (org-element-context)))\n           (on-heading (equal org-context 'heading)))\n      (unless on-heading\n        (outline-previous-heading))\n      (call-interactively 'org-set-tags))))</code></pre>\n\n<h2 id=\"appearance\">Appearance</h2>\n\n<p>These settings modify the appearance of org files.</p>\n\n<pre><code>;; Indent headings by level\n(customize-set-variable 'org-startup-indented t)\n;; Don't turn on truncating long lines in org mode\n(customize-set-variable 'org-startup-truncated nil)</code></pre>")) ((? . 0) f post (u . "Modal Editing in Emacs") (? . 0) 1532058805 (p+ #"/home/lukas/github_sync/projects/website/2018/07/modal-editing-in-emacs.html" . unix) (u . "/2018/07/modal-editing-in-emacs.html") (u . "2018-07-09T02:02:02") (? . 1) (? . 2) (c (u . "emacs")) (u . "\n<p>Modal editing in emacs is easy, and can be much better than vim.</p>") #t (u . "\n<p>Modal editing in emacs is easy, and can be much better than vim.</p>\n<!-- more-->\n\n<br />\n\n<br />\n\n<h1 id=\"emacs-and-vim-modal-editing\">Emacs and vim: modal editing</h1>\n\n<p>The holy war of text editors will never be resolved, because emacs and vim represent wholly different philosophies of what they want to be. Vim wants to be a lightweight yet powerful text editor. <em>Emacs doesn&rsquo;t even want to be a text editor</em>, and it isn&rsquo;t one. Emacs is more aptly described as a text-based programming environment. This is clear when one actually looks at how emacs works and emacs lisp: all editing commands are functions, just as well executed by pressing keys as by an elisp program.</p>\n\n<p>What inevitably comes up in the debate about text editors, however, is not interesting differences like that. One of the main things people argue about is modal editing. Emacs&rsquo; default text insertion strategy is not modal, while vim&rsquo;s is. For many people, modal editing is so fast and effective that this alone makes vim better than emacs.</p>\n\n<p>I actually agree, though not about vim being better ;). Modal editing is, in my opinion, a much more effective way to work with text most of the time. Given what I described above about emacs, however, it should be clear that this is hardly a real difference. It&rsquo;s just a matter of writing the (little bit of) code for modal editing in emacs and binding the code to keys. Or, for those who want things to be as close as possible to vim and/or are lazy, there&rsquo;s <a href=\"https://www.emacswiki.org/emacs/Evil\">EVIL mode</a>.</p>\n\n<p>But I have found writing my own modal editing system beneficial. First of all, I don&rsquo;t think that <em>all</em> of the ways vim does things are great (or even good), though many of them are great. So I want to be able to pick and choose the features I like, and mix in my own useful features. By writing my own mode, I have the power to make the system exactly as I like it.</p>\n\n<p>And it&rsquo;s not even very hard.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"minor-modes-for-modal-editing\">Minor modes for modal editing</h1>\n\n<p>Emacs&rsquo; <a href=\"https://www.gnu.org/software/emacs/manual/html_node/emacs/Modes.html\">system of major and minor modes</a> is quite expressive. Namely, it makes it almost trivial to implement modal editing that works everywhere. Both major and minor modes can create new keybindings. Since major modes change depending on the type of text being worked on, but minor modes generally operate independently of that, a minor mode is the simplest route.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"what-am-i-actually-talking-about\">What am I actually talking about?</h1>\n\n<p>Before describing how to implement modal editing as a minor mode, let&rsquo;s quickly review how modal editing works at an abstract level - so that it&rsquo;s clear why all the pieces are necessary and the roles they play.</p>\n\n<p>Modal editing at its simplest means that text editing is done in two or more modes, each of which has presents a different interface for interacting with text. The simplest way to think of this is probably similar to vim&rsquo;s two primary modes (though I&rsquo;m going to simplify them a bit): &ldquo;insertion&rdquo; and &ldquo;normal&rdquo; modes, which I&rsquo;ll call &ldquo;command&rdquo; mode from here on. In insertion mode, text can be typed, deleted (with backspace), etc, but the cursor can&rsquo;t be moved around and &ldquo;extra&rdquo; operations can&rsquo;t be done. Just typing text. In command mode, the cursor can be moved and text manipulation operations like copy/pasta, search/replace, etc are available; furthermore, these commands can are executed using single key combinations, without any modifiers (ctrl, alt, etc).</p>\n\n<p>This is a simplified version of how vim&rsquo;s modal editing works, and the system below will be a functionally similar approximation. Instead of creating both modes, I approximate emacs&rsquo;s default mode as the equivalent of insert mode: actually, it&rsquo;s much better in my opinion because all of emacs&rsquo; normal bindings to do manipulation are available, just without the single key shortcuts.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"creating-a-custom-editing-minor-mode\">Creating a custom editing minor mode</h1>\n\n<p>As I just mentioned, I don&rsquo;t actually create a special insert mode; I just use emacs&rsquo;s normal bindings. That means all there is to make is the command mode, which provides the single-key shortcuts characteristic of vim.</p>\n\n<p>Every mode in the modal editing system should have a corresponding minor mode - except the normal insertion mode. So one minor mode is necessary to create the command mode. The way it works is simple; when the minor mode is active, we are in command mode, otherwise we aren&rsquo;t. So the way to enter and exit is simply to activate/deactivate the minor mode. Since a minor mode has its own keybindings, the shortcuts will just be keybindings in the minor mode.</p>\n\n<p>Thankfully, creating a new minor mode is easy with <a href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Minor-Modes.html\">define-minor-mode</a>. All that&rsquo;s necessary is a name, docstring, lighter symbol (for indicating on the modeline when the mode is active), and a keymap for bindings.</p>\n\n<pre><code>(define-minor-mode some-mode-name\n  \"Docstring\"\n  ;; initial value\n  nil\n  ;; indicator for mode line\n  \" modeline-indicator\"\n  ;; minor mode bindings\n  '(((kbd \"key string as shown by C-h k\") . some-interactive-function)\n    ...)\n  :group 'some-not-really-important-symbol)</code></pre>\n\n<p>Since this mode will be frequently enabled and disabled in the course of editing, the first command necessary is a toggle function. This is really simple, because <code>define-minor-mode</code> automatically creates a variable with the same name as the mode which is not <code>nil</code> when the mode is active and <code>nil</code> otherwise. Then just bind the keys to enter and exit the command mode, respectively with <code>global-set-key</code> and by placing the binding in the mode&rsquo;s keymap. Picking a good binding to enter the command mode may be difficult (<code>ESC</code> is annoying to rebind because emacs interprets it as an alternative <code>ALT</code> key), so choose wisely; I use <code>M-SPC</code> and quite like it. Here is a MWE providing vim-like hjkl movement. Press <code>M-SPC</code> to enter the mode, and <code>i</code> to exit.</p>\n\n<pre><code>(define-minor-mode my-command-mode\n  \"my-command-mode is a minor mode for modal editing.\n\nUse `toggle-my-command-mode' to enter and exit the mode.\n\nmy-command-mode defines the following bindings:\n\\\\{my-command-mode-map}\n\"\n  ;; initial value\n  nil\n  ;; indicator for mode line\n  \" mcm\"\n  ;; minor mode bindings\n  '(((kbd \"i\") . toggle-my-command-mode)\n\n    ((kbd \"j\") . next-line)\n    ((kbd \"k\") . previous-line)\n    ((kbd \"h\") . backward-char)\n    ((kbd \"l\") . forward-char))\n  :group 'mcm-group)\n\n(defun toggle-my-command-mode (&amp;optional set-state)\n  \"Toggle `my-command-mode', optionally ensuring its state with `SET-STATE'.\n\n`SET-STATE' is interpreted as follows:\n  nil   (Same as no argument) Toggle `my-command-mode'\n  -1    Ensure `my-command-mode' is disabled\n  else  Ensure `my-command-mode' is enabled\n\"\n  (cond ((equal set-state -1)\n         (when my-command-mode\n           (my-command-mode -1)))\n\n        ((equal set-state nil)\n         (my-command-mode (if my-command-mode -1 1)))\n\n        (else\n         (unless my-command-mode\n           (my-command-mode 1)))))\n\n(global-set-key (kbd \"M-SPC\") 'toggle-my-command-mode)</code></pre>\n\n<p>An aside for those unfamiliar with emacs lisp: To try this out just copy-pasta it into any buffer (like <code>*scratch*</code>), highlight it, and execute (with <code>M-x</code>) <code>eval-region</code>. Also, if you&rsquo;re particularly careful about your code, you may be wondering why it&rsquo;s ok that the minor mode definition binds <code>toggle-my-command-mode</code>, even though it isn&rsquo;t defined yet. Actually, the code binding the function to the key just registers the <span class=\"underline\">name</span> of a function and associates it with the key; when that key is pressed, the function associated with the name is looked up dynamically. Thus, it&rsquo;s no problem to provide any arbitrary symbol (defined or not) to the binding code, you&rsquo;ll only run into issues if the symbol is still undefined when the key gets pressed. In this case, the function is defined right away so that won&rsquo;t happen.</p>\n\n<p>Ultimately, this pattern is how much of the functionality of the mode is implemented. For many actions, however, there is likely a built-in command to do it, so use those instead. For example, most basic movement commands are available built-in, like those shown above for moving the cursor bound to hjkl.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"extra-context-menus-with-hydra\">Extra: context menus with hydra</h1>\n\n<p>The excellent <a href=\"https://github.com/abo-abo/hydra\">hydra package</a> provides a great way to create context menus for some of the more specialized commands that one might want bindings for, but may be difficult to memorize. It&rsquo;s very easy to use; for example, here is a hydra that I use for register management.</p>\n\n<pre><code>(defhydra mcm/hydra/registers (:color blue :hint nil)\n    \"\nRegister commands\n_s_: Save point                 _n_: Number to register\n_j_: Jump to register         _i_/_+_: Increment number in register\n_y_: Copy to register           _h_: Show registers\n_p_: Insert from register       _w_: Window config to register\n\"\n    (\"s\" point-to-register)\n    (\"j\" jump-to-register)\n    (\"y\" copy-to-register)\n    (\"p\" insert-register)\n    (\"h\" helm-register)\n    (\"n\" number-to-register)\n    (\"i\" increment-register)\n    (\"+\" increment-register)\n    (\"w\" window-configuration-to-register)\n    (\"q\" nil))\n;; The function to activate this hydra is `mcm/hydra/registers/main'</code></pre>\n\n<br />\n\n<br />\n\n<h1 id=\"my-own-modal-editing-system\">My own modal editing system</h1>\n\n<p>As an example of all of this in practice, <a href=\"https://gist.github.com/LLazarek/d9c226763860c3f53a6d28535e9efb64\">here is the system</a> for modal editing that I have used for the past few years. I called it Nav-mode because initially I started it just for easier navigation; it has since evolved well beyond that, but I see little reason to change the name.</p>\n\n<p>Note that it includes bindings for a number of custom commands and packages I haven&rsquo;t included, so it isn&rsquo;t quite plug and play, but the essence should be clear. Some highlights of extra packages that I use in the mode include <a href=\"https://github.com/emacs-helm/helm\">helm</a>, <a href=\"https://github.com/abo-abo/avy\">avy</a>, <a href=\"https://github.com/magnars/multiple-cursors.el\">multiple-cursors</a>, <a href=\"https://github.com/Fuco1/smartparens\">smartparens</a>, <a href=\"https://github.com/abo-abo/hydra\">hydra</a>.</p>\n\n<br />\n\n<br />\n\n<h1 id=\"thats-it\">That&rsquo;s it!</h1>\n\n<p>Modal editing is not only possible in emacs, it&rsquo;s quite easy. Furthermore, it&rsquo;s highly customizable, allowing me to tailor it precisely to my needs. I have used this particular system of modal editing for a few years and I would unequivocally recommend it to anyone using emacs.</p>")) ((p+ #"/home/lukas/github_sync/projects/website/_src/posts/2018-05-22-ptext.scrbl" . unix) f post (u . "Language-oriented Programming: ptext") (? . 3) 1528409206 (p+ #"/home/lukas/github_sync/projects/website/2018/05/language-oriented-programming-ptext.html" . unix) (u . "/2018/05/language-oriented-programming-ptext.html") (u . "2018-05-22T19:06:27") #f (? . 1) (c (u . "PL") c (u . "racket")) (u . "\n<p>Language-oriented programming in action with racket.</p>") #t (u . "\n<p>Language-oriented programming in action with racket.</p>\n<!--more-->\n\n<blockquote class=\"refpara\">\n <blockquote class=\"refcolumn\">\n  <blockquote class=\"refcontent\">\n   <p><span style=\"font-weight: bold\">Note</span>\nI recently learned about <a href=\"https://docs.racket-lang.org/scribble/index.html\">scribble</a>, and specifically <a href=\"https://docs.racket-lang.org/scribble-pp/index.html\">how scribble as a text preprocessor</a>.\nIt is far superior to ptext in terms of being actually useful.</p></blockquote></blockquote></blockquote>\n\n<p>A year or two ago, I wrote a text preprocessor to allow embedded text\ngeneration using <a href=\"https://racket-lang.org/\">racket</a>.\nThe idea was to be able to embed racket expressions inside a text file\nto manipulate its contents and generate a new file.\nAt its simplest, the tool would just extract the the racket\nexpressions, evaluate them, and insert the results back into the file.\nI came up with the idea because I had a problem with\n<a href=\"https://www.ledger-cli.org/\">ledger</a> that such a tool would\nneatly solve, while possibly being useful for many other similar\nthings.</p>\n\n<p>I used racket mostly because I had just started learning it, and I\ndidn&rsquo;t really leverage any of its most interesting features.\nIn fact, I spent most of my time figuring out how to circumvent some\nof racket&rsquo;s design decisions (like the module system and constrained\n<span class=\"RktSym\">eval</span><span class=\"RktMeta\"></span>).\nI ended up with a few hundred lines of complicated code to do\nsomething that, at least conceptually, is pretty simple.\nNontheless, I learned a good deal and eventually ended up with a\nuseful tool that I used right away to solve a real problem. I was\npretty happy with it, despite its many wrinkles.</p>\n\n<p>Now, working my way through\n<a href=\"https://beautifulracket.com/\">Beautiful Racket</a> I saw\nhow thinking about this same exact problem in terms of a\nDomain-Specific Language can greatly simplify it.\nThe basic idea is that instead of writing a program to take the text\nas input, interpret commands, and produce a new file as output, we can\nsimplify the problem by thinking of the text itself as a program to be\nevaluated.\nThe plain text can be thought of as commands to insert themselves into\nthe output, and the embedded code as commands to insert other things.\nNaturally, I immediately reworked the preprocessor to use this\napproach and after a little bit of fiddling got\n<a href=\"https://github.com/LLazarek/ptext\">ptext</a>.\nThis approach let me build (almost) the same tool in a fraction of the\ncode, and without most of the knots in the previous design.</p>\n\n<p>It works by using a parser generator to generate a parser that\ndistinguishes racket expressions from regular text (using some\ndelimiters), and then converts each of those categories into\nexpressions to be evaluated and printed by racket.\nThe normal text just ends up becoming strings and the expressions get\nwrapped in a print, so when racket runs the resulting program the\noriginal text is printed and the expressions are evaluated and then\nprinted.\nIt&rsquo;s beautifully simple.</p>\n\n<p>I won&rsquo;t go into further detail but do check out\n<a href=\"https://beautifulracket.com/\">Beautiful Racket</a> if you\nare interested.\nIt&rsquo;s really fantastic.\nThis exercise in applying language-oriented programming to one of my\nown tools has served to clearly show me how this approach can be\nuseful.\nI&rsquo;m excited to see where else I might be able to use these ideas.</p>"))))